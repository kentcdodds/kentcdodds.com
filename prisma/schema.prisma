// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Commands to know:
// `npx prisma generate` - update TypeScript definitions based on this schema
// `npx prisma db push` - push the schema changes to the database
// `npx prisma studio` - open the Studio, which allows you to edit the schema.
// `npx prisma migrate reset` - reset the migrations to the last version. This will reset the DB and run the seed script
// `npx prisma migrate dev --name <descriptive-name>` - generate a migration file for any changes you make to the schema (this will be committed).

datasource db {
  provider = "sqlite"
}

generator client {
  provider = "prisma-client"
  output   = "../app/utils/prisma-generated.server"
  runtime = "workerd"
}

model User {
  id        String     @id @default(uuid())
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  email     String     @unique(map: "User.email_unique")
  firstName String
  discordId String?
  kitId     String?
  role      String     @default("MEMBER")
  team      String
  password  Password?
  passkeys  Passkey[]
  calls     Call[]
  callKentCallerEpisodes CallKentCallerEpisode[]
  sessions  Session[]
  postReads PostRead[]
  favorites Favorite[]

  @@index([team])
  @@index([createdAt])
  @@index([role])
}

model Password {
  hash      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique
}

model Verification {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  type      String
  target    String
  codeHash  String
  expiresAt DateTime

  @@index([target, type])
  @@index([expiresAt])
}

model Session {
  id             String   @id @default(uuid())
  createdAt      DateTime @default(now())
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  expirationDate DateTime

  @@index([expirationDate])
}

model Call {
  id          String   @id @default(uuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  title       String
  notes       String?
  isAnonymous Boolean  @default(false)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  // Caller audio is stored in R2; the DB stores metadata + key.
  audioKey         String?
  audioContentType String?
  audioSize        Int?
  episodeDraft CallKentEpisodeDraft?

  @@index([createdAt])
}

enum CallKentEpisodeDraftStatus {
  PROCESSING
  READY
  ERROR
  CANCELLED
}

enum CallKentEpisodeDraftStep {
  STARTED
  GENERATING_AUDIO
  TRANSCRIBING
  GENERATING_METADATA
  DONE
}

model CallKentEpisodeDraft {
  id            String   @id @default(uuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  status        CallKentEpisodeDraftStatus @default(PROCESSING)
  step          CallKentEpisodeDraftStep   @default(STARTED)
  errorMessage  String?

  // Episode audio is stored in R2 and proxied for playback/publish.
  episodeAudioKey         String?
  episodeAudioContentType String?
  episodeAudioSize        Int?

  // Generated before publish so AI can write metadata; admin can edit.
  transcript    String?
  title         String?
  description   String?
  keywords      String?

  call          Call     @relation(fields: [callId], references: [id], onDelete: Cascade)
  callId        String   @unique

  @@index([status, updatedAt])
}

model CallKentCallerEpisode {
  id               String   @id @default(uuid())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId           String

  // Preserve what the caller set at the time of the call.
  callTitle        String
  callNotes        String?
  isAnonymous      Boolean  @default(false)

  // Episode identity on Transistor. Everything else is derived via cached Transistor lookups.
  transistorEpisodeId String @unique

  @@index([userId, createdAt])
}

model PostRead {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String?
  clientId  String?
  postSlug  String

  @@index([userId, postSlug])
  @@index([clientId, postSlug])
  @@index([postSlug, createdAt])
  @@index([createdAt, userId])
}

model Passkey {
  id             String   @id
  aaguid         String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  publicKey      Bytes
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  webauthnUserId String
  counter        BigInt
  deviceType     String // 'singleDevice' or 'multiDevice'
  backedUp       Boolean
  transports     String? // Stored as comma-separated values

  @@index(userId)
}

model Favorite {
  id          String   @id @default(uuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  contentType String
  contentId   String

  @@unique([userId, contentType, contentId])
  @@index([userId, createdAt])
  @@index([contentType, contentId])
}
