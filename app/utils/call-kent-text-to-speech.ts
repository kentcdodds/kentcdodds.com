export const callKentTextToSpeechConstraints = {
	questionText: {
		minLength: 20,
		// Roughly sized so most questions land under ~2 minutes.
		maxLength: 2000,
	},
	// UI and submission safety limit; actual audio length depends on voice and pacing.
	maxAudioDurationSeconds: 120,
} as const

export const AI_VOICE_DISCLOSURE_PREFIX = `This caller's voice was generated by AI.`

export function formatCallKentTextToSpeechNotes(questionText: string) {
	const cleaned = questionText.trim()
	if (!cleaned) return cleaned

	// Callers can paste the disclosure prefix into the textarea. Avoid duplicating
	// it when formatting notes for the call record.
	const prefixLower = AI_VOICE_DISCLOSURE_PREFIX.toLowerCase()
	const questionBody = cleaned.toLowerCase().startsWith(prefixLower)
		? cleaned.slice(AI_VOICE_DISCLOSURE_PREFIX.length).trimStart()
		: cleaned

	return `${AI_VOICE_DISCLOSURE_PREFIX}\nTyped question: ${questionBody}`
}

// @cf/deepgram/aura-2-en supports many speakers; we offer a curated subset.
const auraSpeakers = [
	'apollo',
	'arcas',
	'orion',
	'luna',
	'andromeda',
	'helena',
	'athena',
	'zeus',
] as const

export type CallKentTextToSpeechVoice = (typeof auraSpeakers)[number]

export const callKentTextToSpeechVoices: Array<{
	id: CallKentTextToSpeechVoice
	label: string
}> = auraSpeakers.map((speaker) => ({
	id: speaker,
	label: speaker.charAt(0).toUpperCase() + speaker.slice(1),
}))

export function getCallKentVoicePreviewSrc(voice: CallKentTextToSpeechVoice) {
	return `/audio/call-kent-voices/${voice}.mp3`
}

export function isCallKentTextToSpeechVoice(
	voice: string,
): voice is CallKentTextToSpeechVoice {
	return (auraSpeakers as readonly string[]).includes(voice)
}

export function getErrorForCallKentQuestionText(value: string | null) {
	if (!value) return 'Question text is required'
	const text = value.trim()
	if (!text) return 'Question text is required'

	const { minLength, maxLength } = callKentTextToSpeechConstraints.questionText
	if (text.length < minLength) {
		return `Question text must be at least ${minLength} characters`
	}
	if (text.length > maxLength) {
		return `Question text must be no longer than ${maxLength} characters`
	}
	return null
}
