type RequestLogEntry = {
	id: number
	method: string
	path: string
	query: string
	createdAt: string
}

type VectorRecord = {
	id: string
	values: number[]
	metadata: Record<string, unknown>
	namespace: string
}

type Envelope<T> = {
	success: boolean
	errors: Array<{ code: number; message: string }>
	messages: Array<{ code: number; message: string }>
	result: T
}

type CloudflareApiRoute =
	| {
			kind: 'workers-ai-run'
			accountId: string
			model: string
	  }
	| {
			kind:
				| 'vectorize-query'
				| 'vectorize-upsert'
				| 'vectorize-insert'
				| 'vectorize-delete-by-ids'
			accountId: string
			indexName: string
	  }

const requestLog: Array<RequestLogEntry> = []
let nextRequestId = 1

const vectorIndexes = new Map<string, Map<string, Map<string, VectorRecord>>>()
const embeddingToText = new Map<string, string>()
const DEFAULT_EMBEDDING_DIMS = 12

export default {
	async fetch(
		request: Request,
		_unusedEnv: unknown,
		_unusedCtx: unknown,
	): Promise<Response> {
		const url = new URL(request.url)
		recordRequest({
			method: request.method,
			path: url.pathname,
			query: url.search,
		})

		if (url.pathname === '/__mocks/meta') {
			return jsonResponse({
				service: 'cloudflare',
				description: 'Mock Cloudflare API + AI Gateway + Vectorize worker',
				dashboard: '/__mocks',
				themeSupport: ['light', 'dark'],
				responsive: true,
				requestCount: requestLog.length,
			})
		}

		if (url.pathname === '/__mocks/requests') {
			return jsonResponse({ requests: [...requestLog].reverse() })
		}

		if (url.pathname === '/__mocks/reset' && request.method === 'POST') {
			requestLog.length = 0
			nextRequestId = 1
			vectorIndexes.clear()
			embeddingToText.clear()
			return jsonResponse({ success: true })
		}

		if (url.pathname === '/__mocks') {
			return htmlResponse(renderDashboard())
		}

		if (
			request.method === 'POST' &&
			url.pathname.startsWith('/gateway/v1/') &&
			url.pathname.includes('/workers-ai/')
		) {
			const model = decodeWorkersAiModel(url.pathname)
			if (!model) {
				return jsonError(400, 'Missing workers-ai model segment')
			}
			return handleWorkersAiRequest({ request, model })
		}

		const route = parseCloudflareApiRoute(url.pathname)
		if (route && request.method === 'POST') {
			if (route.kind === 'workers-ai-run') {
				return handleWorkersAiRequest({
					request,
					model: route.model,
				})
			}
			if (route.kind === 'vectorize-query') {
				return handleVectorizeQuery({
					request,
					accountId: route.accountId,
					indexName: route.indexName,
				})
			}
			if (route.kind === 'vectorize-upsert') {
				return handleVectorizeWrite({
					request,
					accountId: route.accountId,
					indexName: route.indexName,
					operation: 'upsert',
				})
			}
			if (route.kind === 'vectorize-insert') {
				return handleVectorizeWrite({
					request,
					accountId: route.accountId,
					indexName: route.indexName,
					operation: 'insert',
				})
			}
			if (route.kind === 'vectorize-delete-by-ids') {
				return handleVectorizeDeleteByIds({
					request,
					accountId: route.accountId,
					indexName: route.indexName,
				})
			}
		}

		return jsonResponse(
			{
				error: `Unhandled mock request: ${request.method} ${url.pathname}`,
			},
			404,
		)
	},
}

async function handleWorkersAiRequest({
	request,
	model,
}: {
	request: Request
	model: string
}) {
	const contentType = (request.headers.get('content-type') ?? '').toLowerCase()
	const lowerModel = model.toLowerCase()

	if (contentType.includes('audio/')) {
		return jsonEnvelope({
			text: `Mock transcription (${model}): hello from Workers AI.`,
		})
	}

	const body = await safeJson(request)

	if (
		lowerModel.includes('deepgram/aura') ||
		lowerModel.includes('aura-') ||
		lowerModel.includes('melotts')
	) {
		const text =
			typeof body?.text === 'string'
				? body.text
				: typeof body?.prompt === 'string'
					? body.prompt
					: ''
		if (!text.trim()) {
			return jsonError(400, 'Expected JSON body { text: string } for TTS')
		}
		const wav = makePcm16SineWaveWav({
			durationSeconds: 6,
			frequencyHz: frequencyFromSpeakerAndText(
				typeof body?.speaker === 'string' ? body.speaker : 'luna',
				text,
			),
		})
		return new Response(wav, {
			status: 200,
			headers: {
				'content-type': 'audio/wav',
				'cache-control': 'no-store',
			},
		})
	}

	if (
		(Array.isArray(body?.messages) && body.messages.length > 0) ||
		(typeof body?.prompt === 'string' && body.prompt.trim())
	) {
		return jsonEnvelope({
			response: JSON.stringify({
				title: `Mock Call Kent episode title (${model})`,
				description:
					'Mock description generated by Workers AI. This is a placeholder used in local mocks.',
				keywords: 'call kent, mock, podcast, workers ai, transcript',
			}),
		})
	}

	const texts: string[] = Array.isArray(body?.text)
		? body.text.filter((entry: unknown): entry is string => {
				return typeof entry === 'string' && entry.trim().length > 0
			})
		: []
	if (texts.length === 0) {
		return jsonError(400, 'Expected JSON body { text: string[] } for embeddings')
	}

	const data = texts.map((text) => {
		const vector = textToEmbedding(text, DEFAULT_EMBEDDING_DIMS)
		embeddingToText.set(vectorKey(vector), text)
		return vector
	})
	return jsonEnvelope({
		shape: [texts.length, DEFAULT_EMBEDDING_DIMS],
		data,
	})
}

async function handleVectorizeQuery({
	request,
	accountId,
	indexName,
}: {
	request: Request
	accountId: string
	indexName: string
}) {
	const body = await safeJson(request)
	const vector = Array.isArray(body?.vector)
		? body.vector.filter(
				(entry: unknown): entry is number => typeof entry === 'number',
			)
		: []
	if (vector.length === 0) {
		return jsonError(400, 'Expected JSON body { vector: number[] }.')
	}

	const topK =
		typeof body?.topK === 'number' && Number.isFinite(body.topK)
			? Math.max(1, Math.min(100, Math.floor(body.topK)))
			: 10
	const namespace =
		typeof body?.namespace === 'string' && body.namespace.trim()
			? body.namespace.trim()
			: undefined

	const store = getOrCreateIndexStore(accountId, indexName)
	const vectors = allVectors(store, namespace)
	const queryText = embeddingToText.get(vectorKey(vector))

	if (queryText) {
		const prioritized = vectors
			.filter((entry) => {
				const metadataText = `${entry.metadata.title ?? ''} ${entry.metadata.snippet ?? ''} ${entry.metadata.url ?? ''}`
					.toLowerCase()
				return metadataText.includes(queryText.toLowerCase())
			})
			.slice(0, topK)
			.map((entry, index) => ({
				id: entry.id,
				score: Math.max(0, 0.99 - index * 0.02),
				metadata: entry.metadata,
			}))
		if (prioritized.length > 0) {
			return jsonEnvelope({
				count: prioritized.length,
				matches: prioritized,
			})
		}
	}

	const matches = vectors
		.map((entry) => ({
			id: entry.id,
			score: scoreFromSimilarity(cosineSimilarity(vector, entry.values)),
			metadata: entry.metadata,
		}))
		.sort((left, right) => right.score - left.score)
		.slice(0, topK)

	return jsonEnvelope({
		count: matches.length,
		matches,
	})
}

async function handleVectorizeWrite({
	request,
	accountId,
	indexName,
	operation,
}: {
	request: Request
	accountId: string
	indexName: string
	operation: 'insert' | 'upsert'
}) {
	const parsed = await parseVectorsPayload(request)
	if (!parsed.ok) return jsonError(400, parsed.error)

	const store = getOrCreateIndexStore(accountId, indexName)
	let updated = 0
	for (const vector of parsed.vectors) {
		let namespaceStore = store.get(vector.namespace)
		if (!namespaceStore) {
			namespaceStore = new Map<string, VectorRecord>()
			store.set(vector.namespace, namespaceStore)
		}

		if (operation === 'insert' && namespaceStore.has(vector.id)) {
			return jsonError(409, `Vector already exists: ${vector.id}`)
		}

		namespaceStore.set(vector.id, vector)
		updated += 1
	}

	return jsonEnvelope({
		operation,
		updated,
	})
}

async function handleVectorizeDeleteByIds({
	request,
	accountId,
	indexName,
}: {
	request: Request
	accountId: string
	indexName: string
}) {
	const body = await safeJson(request)
	const ids = Array.isArray(body?.ids)
		? body.ids.filter(
				(entry: unknown): entry is string =>
					typeof entry === 'string' && entry.trim().length > 0,
			)
		: []
	if (ids.length === 0) {
		return jsonError(400, 'Expected JSON body { ids: string[] }.')
	}

	const store = getOrCreateIndexStore(accountId, indexName)
	let deleted = 0
	for (const namespaceStore of store.values()) {
		for (const id of ids) {
			if (namespaceStore.delete(id)) deleted += 1
		}
	}

	return jsonEnvelope({ deleted })
}

function parseCloudflareApiRoute(pathname: string): CloudflareApiRoute | null {
	const parts = pathname.split('/').filter(Boolean)
	if (parts.length < 6) return null
	if (parts[0] !== 'client' || parts[1] !== 'v4' || parts[2] !== 'accounts') {
		return null
	}

	const accountId = decodeURIComponent(parts[3] ?? '')
	const firstSegment = parts[4]
	if (firstSegment === 'ai' && parts[5] === 'run') {
		const model = decodeURIComponent(parts.slice(6).join('/'))
		if (!model) return null
		return {
			kind: 'workers-ai-run',
			accountId,
			model,
		}
	}

	if (firstSegment !== 'vectorize') return null

	let cursor = 5
	if (parts[cursor] === 'v2') cursor += 1
	if (parts[cursor] !== 'indexes') return null
	const indexName = decodeURIComponent(parts[cursor + 1] ?? '')
	const operation = parts[cursor + 2] ?? ''
	if (!indexName || !operation) return null

	if (operation === 'query') {
		return { kind: 'vectorize-query', accountId, indexName }
	}
	if (operation === 'upsert') {
		return { kind: 'vectorize-upsert', accountId, indexName }
	}
	if (operation === 'insert') {
		return { kind: 'vectorize-insert', accountId, indexName }
	}
	if (operation === 'delete_by_ids') {
		return { kind: 'vectorize-delete-by-ids', accountId, indexName }
	}

	return null
}

function decodeWorkersAiModel(pathname: string) {
	const marker = '/workers-ai/'
	const markerIndex = pathname.indexOf(marker)
	if (markerIndex < 0) return null
	const raw = pathname.slice(markerIndex + marker.length)
	if (!raw) return null
	return decodeURIComponent(raw)
}

function getOrCreateIndexStore(accountId: string, indexName: string) {
	const key = `${accountId}:${indexName}`
	let store = vectorIndexes.get(key)
	if (!store) {
		store = new Map<string, Map<string, VectorRecord>>()
		vectorIndexes.set(key, store)
	}
	return store
}

function allVectors(
	store: Map<string, Map<string, VectorRecord>>,
	namespace?: string,
) {
	if (namespace) return Array.from(store.get(namespace)?.values() ?? [])
	return Array.from(store.values()).flatMap((entry) => Array.from(entry.values()))
}

async function parseVectorsPayload(request: Request) {
	const contentType = (request.headers.get('content-type') ?? '').toLowerCase()

	let ndjson = ''
	if (contentType.includes('application/x-ndjson')) {
		ndjson = await request.text()
	} else if (contentType.includes('multipart/form-data')) {
		const form = await request.formData()
		const vectorsPart = form.get('vectors')
		if (!vectorsPart) {
			return {
				ok: false as const,
				error: 'Missing "vectors" multipart field.',
			}
		}
		ndjson =
			typeof vectorsPart === 'string'
				? vectorsPart
				: await vectorsPart.text()
	} else {
		return {
			ok: false as const,
			error: 'Expected multipart/form-data or application/x-ndjson payload.',
		}
	}

	const vectors: VectorRecord[] = []
	for (const line of ndjson.split('\n').map((entry) => entry.trim())) {
		if (!line) continue
		let parsed: any
		try {
			parsed = JSON.parse(line)
		} catch {
			return {
				ok: false as const,
				error: 'Invalid NDJSON payload for vectors.',
			}
		}
		const id = typeof parsed?.id === 'string' ? parsed.id.trim() : ''
		const values = Array.isArray(parsed?.values)
			? parsed.values.filter(
					(entry: unknown): entry is number => typeof entry === 'number',
				)
			: []
		if (!id || values.length === 0) {
			return {
				ok: false as const,
				error: 'Each vector must include { id: string, values: number[] }.',
			}
		}
		vectors.push({
			id,
			values,
			namespace:
				typeof parsed?.namespace === 'string' && parsed.namespace.trim()
					? parsed.namespace.trim()
					: 'default',
			metadata:
				parsed?.metadata && typeof parsed.metadata === 'object'
					? (parsed.metadata as Record<string, unknown>)
					: {},
		})
	}

	return {
		ok: true as const,
		vectors,
	}
}

function vectorKey(vector: number[]) {
	return vector.map((entry) => entry.toFixed(6)).join(',')
}

function textToEmbedding(text: string, dims: number) {
	const hash = simpleHash(text)
	const values: number[] = []
	for (let index = 0; index < dims; index += 1) {
		const byte = hash[index % hash.length] ?? 0
		values.push((byte / 255) * 2 - 1)
	}
	return values
}

function simpleHash(text: string) {
	const bytes = new TextEncoder().encode(text)
	const hash = new Uint8Array(32)
	for (let index = 0; index < bytes.length; index += 1) {
		const value = bytes[index] ?? 0
		hash[index % hash.length] = (hash[index % hash.length]! + value + index) % 256
	}
	return hash
}

function dot(left: number[], right: number[]) {
	const length = Math.min(left.length, right.length)
	let sum = 0
	for (let index = 0; index < length; index += 1) {
		sum += (left[index] ?? 0) * (right[index] ?? 0)
	}
	return sum
}

function norm(values: number[]) {
	let sum = 0
	for (const value of values) sum += value * value
	return Math.sqrt(sum)
}

function cosineSimilarity(left: number[], right: number[]) {
	const leftNorm = norm(left)
	const rightNorm = norm(right)
	if (!leftNorm || !rightNorm) return 0
	return dot(left, right) / (leftNorm * rightNorm)
}

function scoreFromSimilarity(similarity: number) {
	return clamp((similarity + 1) / 2, 0, 1)
}

function clamp(value: number, min: number, max: number) {
	return Math.min(max, Math.max(min, value))
}

function frequencyFromSpeakerAndText(speaker: string, text: string) {
	const seed = `${speaker}:${text.slice(0, 64)}`
	const hash = simpleHash(seed)
	const firstByte = hash[0] ?? 0
	return 220 + Math.round((firstByte / 255) * 660)
}

function makePcm16SineWaveWav({
	durationSeconds,
	frequencyHz,
	sampleRate = 8000,
	amplitude = 0.25,
}: {
	durationSeconds: number
	frequencyHz: number
	sampleRate?: number
	amplitude?: number
}) {
	const safeDuration = clamp(durationSeconds, 0.25, 30)
	const numSamples = Math.floor(safeDuration * sampleRate)
	const dataSize = numSamples * 2
	const buffer = new ArrayBuffer(44 + dataSize)
	const view = new DataView(buffer)
	const bytes = new Uint8Array(buffer)

	writeAscii(bytes, 0, 'RIFF')
	view.setUint32(4, 36 + dataSize, true)
	writeAscii(bytes, 8, 'WAVE')
	writeAscii(bytes, 12, 'fmt ')
	view.setUint32(16, 16, true)
	view.setUint16(20, 1, true)
	view.setUint16(22, 1, true)
	view.setUint32(24, sampleRate, true)
	view.setUint32(28, sampleRate * 2, true)
	view.setUint16(32, 2, true)
	view.setUint16(34, 16, true)
	writeAscii(bytes, 36, 'data')
	view.setUint32(40, dataSize, true)

	const twoPiF = 2 * Math.PI * frequencyHz
	const scale = clamp(amplitude, 0, 1) * 32767
	for (let index = 0; index < numSamples; index += 1) {
		const t = index / sampleRate
		const sample = Math.round(Math.sin(twoPiF * t) * scale)
		view.setInt16(44 + index * 2, sample, true)
	}

	return bytes
}

function writeAscii(target: Uint8Array, offset: number, value: string) {
	for (let index = 0; index < value.length; index += 1) {
		target[offset + index] = value.charCodeAt(index)
	}
}

function recordRequest({
	method,
	path,
	query,
}: {
	method: string
	path: string
	query: string
}) {
	requestLog.push({
		id: nextRequestId++,
		method,
		path,
		query,
		createdAt: new Date().toISOString(),
	})
	if (requestLog.length > 500) {
		requestLog.shift()
	}
}

async function safeJson(request: Request) {
	try {
		return await request.json()
	} catch {
		return null
	}
}

function jsonEnvelope<T>(result: T, status = 200) {
	const body: Envelope<T> = {
		success: true,
		errors: [],
		messages: [],
		result,
	}
	return jsonResponse(body, status)
}

function jsonError(status: number, message: string) {
	const body: Envelope<null> = {
		success: false,
		errors: [{ code: 10000, message }],
		messages: [],
		result: null,
	}
	return jsonResponse(body, status)
}

function jsonResponse(data: unknown, status = 200) {
	return new Response(JSON.stringify(data, null, 2), {
		status,
		headers: {
			'content-type': 'application/json; charset=utf-8',
			'cache-control': 'no-store',
		},
	})
}

function htmlResponse(html: string) {
	return new Response(html, {
		headers: {
			'content-type': 'text/html; charset=utf-8',
			'cache-control': 'no-store',
		},
	})
}

function renderDashboard() {
	const rows = [...requestLog]
		.reverse()
		.slice(0, 80)
		.map(
			(entry) => `<tr>
      <td>${entry.id}</td>
      <td>${escapeHtml(entry.method)}</td>
      <td>${escapeHtml(entry.path + entry.query)}</td>
      <td>${escapeHtml(entry.createdAt)}</td>
    </tr>`,
		)
		.join('\n')
	return `<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cloudflare Mock Dashboard</title>
    <style>
      :root { color-scheme: light dark; --bg: #fff; --fg: #0f172a; --muted: #64748b; --border: #cbd5e1; }
      @media (prefers-color-scheme: dark) { :root { --bg: #0b1120; --fg: #e2e8f0; --muted: #94a3b8; --border: #334155; } }
      body { margin: 0; font-family: ui-sans-serif, system-ui, sans-serif; background: var(--bg); color: var(--fg); }
      .layout { padding: 1rem; max-width: 1100px; margin: 0 auto; }
      .summary { color: var(--muted); }
      .toolbar { display: flex; gap: 0.5rem; margin: 1rem 0; flex-wrap: wrap; }
      button { border: 1px solid var(--border); background: transparent; color: inherit; border-radius: 0.5rem; padding: 0.5rem 0.75rem; cursor: pointer; }
      table { width: 100%; border-collapse: collapse; border: 1px solid var(--border); }
      th, td { border-bottom: 1px solid var(--border); padding: 0.5rem; text-align: left; }
      code { font-family: ui-monospace, Menlo, Monaco, "Courier New", monospace; }
      @media (max-width: 720px) { table, thead, tbody, tr, th, td { display: block; } thead { display: none; } }
    </style>
  </head>
  <body>
    <main class="layout">
      <h1>Cloudflare Mock Dashboard</h1>
      <p class="summary">Workers AI, Vectorize, and API request history.</p>
      <p class="summary">
        Expected local routes:
        <code>/gateway/v1/:account/:gateway/workers-ai/:model</code> and
        <code>/client/v4/accounts/:account/*</code>
      </p>
      <div class="toolbar">
        <button id="refresh" type="button">Refresh</button>
        <button id="reset" type="button">Reset state</button>
      </div>
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Method</th>
            <th>Path</th>
            <th>Time</th>
          </tr>
        </thead>
        <tbody>
          ${rows || '<tr><td colspan="4">No requests yet.</td></tr>'}
        </tbody>
      </table>
    </main>
    <script>
      document.getElementById('refresh')?.addEventListener('click', () => window.location.reload())
      document.getElementById('reset')?.addEventListener('click', async () => {
        await fetch('/__mocks/reset', { method: 'POST' })
        window.location.reload()
      })
    </script>
  </body>
</html>`
}

function escapeHtml(value: string) {
	return value
		.replaceAll('&', '&amp;')
		.replaceAll('<', '&lt;')
		.replaceAll('>', '&gt;')
		.replaceAll('"', '&quot;')
		.replaceAll("'", '&#39;')
}
